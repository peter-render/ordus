unit funclibProj;

interface

uses datamodule, messages, sysutils, dbtables, forms, windows, typinfo,
  stdctrls, controls, graphics, wwdbgrid, comobj, dialogs, DB, printers,
  comctrls, classes,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf,
  FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async,
  FireDAC.Phys,
  FireDAC.Comp.Client, FireDAC.Phys.ODBCBase, FireDAC.Phys.MSSQL,
  FireDAC.VCLUI.Wait, FireDAC.Comp.UI,
  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt,
  FireDAC.Comp.DataSet, system.Variants;

procedure ReadOrderfileIntersystem(filename: string);
procedure ReadOrderfileIntersystemXML(xmlfilename: string);

implementation

uses funclib, IntersystemOrder;

function VarTypeIsStr(const AVarType: TVarType): Boolean;
begin
  Result := (AVarType = varOleStr) or (AVarType = varString) or
    (AVarType = varUString);
end;

function VarIsStr(const V: Variant): Boolean;
begin
  Result := VarTypeIsStr(FindVarData(V)^.VType);
end;

function VarStrEmpty(V: Variant): Boolean;
var
  data: PVarData;
begin
  data := FindVarData(V);

  case data^.VType of
    varOleStr:
      Result := (data^.VOleStr^ = #0);
    varString:
      Result := (data^.VString = nil);
    varUString:
      Result := (data^.VUString = nil);
  else
    Result := false;
  end;
end;

procedure ReadOrderfileIntersystemXML(xmlfilename: string);

var
  Orders420: IXMLORDERS420Type;
  X: INTEGER;
  i: INTEGER;
  sv: string;
  strOrdernummer: string;

  strMärke: string;
  strVarRef: string;
  strOrderDate: string;
  strLevDatum: string;
  intOrderId: INTEGER;
  deliveryDate: Tdatetime;
  IntRadnr: INTEGER;
  strArtikelnr: string;
  StrBenamning: string;
  strAntal: string;
  IntradnrOld: INTEGER;
  n: INTEGER;
  strOrderinfo: string;
  TOTALN, IntAntal: INTEGER;

begin
  Orders420 := LoadORDERS420(xmlfilename);

  strOrdernummer := Orders420.Order.OrderNumber;
  strOrderDate := Orders420.Order.Head.Terms.OrderDate;

  // if VarStrEmpty(Orders420.Order.Head.References.GoodsLabeling.Row1) then
  if NOT VarIsStr(Orders420.Order.Head.References.GoodsLabeling.Row1) then
    strMärke := ''
  else
    strMärke := Orders420.Order.Head.References.GoodsLabeling.Row1;

  strVarRef := Orders420.Order.Head.References.BuyerReference;

  // Ta reda på tidigaste Leveransdatum

  deliveryDate := strtodate('9999-12-31');

  TOTALN := Orders420.Order.Rows.Count;

  for i := 0 to TOTALN - 1 do
  begin
    if Orders420.Order.Rows[i].RowType = 1 then
    begin
      if Orders420.Order.Rows[i].DeliveryPeriod < deliveryDate then
        deliveryDate := Orders420.Order.Rows[i].DeliveryPeriod;
    end;
  end;

  if datetostr(deliveryDate) = '9999-12-31' then
    deliveryDate := strtodate('');

  // Skapa Ordderhuvud
  with dm.sp do
  begin
    ParamByName('@Kundid').value := 1;
    ParamByName('@ordernummer').value := strOrdernummer;
    ParamByName('@orderdatum').value := strtodate(strOrderDate);
    ParamByName('@Godsmärke').value := strMärke;
    ParamByName('@Referens').value := strVarRef;
    ParamByName('@Leveransdatum').value := deliveryDate;
    execproc;
    intOrderId := ParamByName('@OrderID').value;

  end;

  (*
    Memo1.Clear;
    memo1.Lines.Add(Orders420.Order.OrderNumber );
    memo1.Lines.Add(Orders420.Order.Head.References.BuyerReference);
    memo1.Lines.Add(Orders420.Order.Head.References.GoodsLabeling.Row1);
    memo1.Lines.Add(Orders420.Order.Head.DeliveryAddress.Name);
    memo1.Lines.Add(Orders420.Order.Head.DeliveryAddress.StreetBox1);
    memo1.Lines.Add(Orders420.Order.Head.DeliveryAddress.ZipCity1);
    memo1.Lines.Add(Orders420.Order.Head.Terms.OrderDate);
    memo1.Lines.Add('');
  *)

  IntradnrOld := 0;
  i := 0;

//  while i < (TOTALN - 1) do

  while i < (TOTALN) do
  begin
    strOrderinfo := '';
    IntRadnr := Orders420.Order.Rows[i].RowNumber;

    if Orders420.Order.Rows[i].RowType = 2 then
      strArtikelnr := '999999'
    else
      strArtikelnr := Orders420.Order.Rows[i].Part.PartNumber;

    StrBenamning := Orders420.Order.Rows[i].Text;
    IntAntal := Orders420.Order.Rows[i].Quantity;

    // Finns textrader?

    if n < TOTALN - 1 then
    BEGIN

      n := i + 1; // är nästa rad samm artikel/radnr

      if n < TOTALN then

        while (Orders420.Order.Rows[n].RowNumber = IntRadnr) do
        begin

          if (Orders420.Order.Rows[n].RowType = 4) and
            (Orders420.Order.Rows[n].Text <> '') THEN

            strOrderinfo := strOrderinfo + ' & ' + Orders420.Order.Rows[n].Text;

          (* strOrderinfo := strOrderinfo + iif(strOrderinfo <> '',
            char(13) + chr(10), '') + Orders420.Order.Rows[n].Text;
          *)
          inc(n);

          if n > TOTALN - 1 then
            break;

        end;

      // nästa i = n-1
      i := n - 1;

    END;

    // if n >= 67 THEN
    // SHOWMESSAGE('67');

    strOrderinfo := trim(strOrderinfo);

    with dm.sp_OrderRadImport do
    begin
      ParamByName('@Positionnummer').value := IntRadnr;
      ParamByName('@KundId').value := 1;
      ParamByName('@OrderId').value := intOrderId;
      ParamByName('@Artikelnummer').value := strArtikelnr;
      ParamByName('@Artikelbeteckning').value := StrBenamning;
      if IntAntal > 0 then
        ParamByName('@Antal').value := IntAntal;
      ParamByName('@OrderradInfo').value := strOrderinfo;

      (*
        if cbImportPris.checked then
        parameters.ParamByName('@PrisperEnhet').value := strtofloat(li.subitems[2])
        else
        parameters.ParamByName('@PrisperEnhet').value := 0;
      *)

      execproc;
    end;
    inc(i);
  end;
end;

procedure ReadOrderfileIntersystem(filename: string);

var
  radnr: INTEGER;
  i: INTEGER;
  ListItem: TListItem;
  NewColumn: TListColumn;
  dat: Tdatetime;
  intOrderId: INTEGER;
  strArtikelBeteckning, strPris: string;
  csv: TStringlist;
  fieldcount: INTEGER;
  recordcount: INTEGER;
  separator: char;
  Result: INTEGER;
  s: string;
  _s: string;
  pos: INTEGER;
  lastpos: INTEGER;
  strOrdernummer, strLevDatum, strAntal, StrBenamning, strArtikelnr, strMärke,
    strLevSatt, strVarRef, strBeställare, strrubrik: string;

begin

  if lowercase(extractfileext(filename)) <> '.csv' then
    exit;

  strrubrik := '';
  strOrdernummer := Parse('.', extractfilename(filename), 1);

  if length(strOrdernummer) > 30 then
  begin
    messagedlg
      ('Ordernummer är längre än 30 tecken - ordern kan inte importeras!',
      mtError, [mbOK], 0);
    exit;
  end;

  fieldcount := 0;
  recordcount := 0;
  Result := 0;
  separator := ';';

  csv := TStringlist.create;
  try
    // read file to csv
    try
      csv.loadfromfile(filename);
    except
      Result := 1;
      exit;
    end;

    if Parse(';', trim(csv[0]), 1) <> 'LevBest' then
    begin
      showmessage
        ('Dokument innhåller ingen giltig Intersystem leverantörsbeställning');
    end;

    recordcount := csv.Count;
    i := 0;

    while i < recordcount do
    begin

      s := trim(csv[i]);

      if s <> '' then
        strrubrik := (Parse(';', s, 1))
      else
        strrubrik := '';

      if strrubrik = 'Beställare' then
        strBeställare := trim(Parse(';', s, 2));

      if strrubrik = 'LevDatum' then
        strLevDatum := trim(Parse(';', s, 2));

      if strrubrik = 'Vår ref' then
        strVarRef := trim(Parse(';', s, 2));

      if strrubrik = 'LevSätt' then
        strLevSatt := trim(Parse(';', s, 2));

      if strrubrik = 'Märke' then
        strMärke := trim(Parse(';', s, 2));

      if strrubrik = 'Artnr' then
      begin

        // Skapa Ordderhuvud
        with dm.sp do
        begin
          ParamByName('@Kundid').value := 1;
          ParamByName('@ordernummer').value := strOrdernummer;
          ParamByName('@orderdatum').value := date;
          ParamByName('@Godsmärke').value := strMärke;
          ParamByName('@Referens').value := strVarRef;
          ParamByName('@Leveransdatum').value := strtodate(strLevDatum);
          execproc;
          intOrderId := ParamByName('@OrderID').value;
        end;

        i := i + 1;
        s := trim(csv[i]);

        while (Parse(';', s, 1) <> '') and (s <> '') do
        begin
          strArtikelnr := stringreplace(Parse(';', s, 1), ' ', '', []);
          StrBenamning := Parse(';', s, 2);
          // LevArtnr läses inte in för tillfälle
          strAntal := Parse(';', s, 4);
          strLevDatum := Parse(';', s, 5);

          // Importera raderna

          if strArtikelnr <> 'T' then

            with dm.sp_OrderRadImport do
            begin
              ParamByName('@KundId').value := 1;
              ParamByName('@OrderId').value := intOrderId;
              ParamByName('@Artikelnummer').value := strArtikelnr;
              ParamByName('@Artikelbeteckning').value := StrBenamning;
              ParamByName('@Antal').value := strtofloat(strAntal);
              (*
                if cbImportPris.checked then
                parameters.ParamByName('@PrisperEnhet').value := strtofloat(li.subitems[2])
                else
                parameters.ParamByName('@PrisperEnhet').value := 0;
              *)
              ParamByName('@Positionnummer').value := i + 1;
              execproc;

            end;
          i := i + 1;
          if (i >= recordcount) then
            break;
          s := trim(csv[i])

        end;

      end;
      i := i + 1;
    end;
  finally
    csv.free;
  end;
end;

end.
